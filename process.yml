# Orb 'circleci/orb-tools@10.0.3' resolved to 'circleci/orb-tools@10.0.3'
# Orb 'circleci/bats@1.0' resolved to 'circleci/bats@1.0.1'
# Orb 'circleci/shellcheck@2.0' resolved to 'circleci/shellcheck@2.0.0'
# Orb 'circleci/node@4.2.0' resolved to 'circleci/node@4.2.0'
version: 2
jobs:
  orb-tools/lint:
    docker:
    - image: singapore/lint-condo
    resource_class: small
    steps:
    - run:
        command: |
          apk --update add git openssh
        name: Install Git and Openssh
    - checkout
    - run:
        command: |-
          touch .yamllint || true
          cat << EOF > .yamllint
          extends: relaxed

          rules:
              line-length:
                  max: 200
                  allow-non-breakable-inline-mappings: true

          EOF
        name: output default .yamllint file in the working directory
    - run:
        command: |
          yamllint .
        name: yamllint
  orb-tools/pack:
    docker:
    - image: circleci/circleci-cli:latest
    steps:
    - checkout
    - run:
        command: |
          mkdir -pv $(dirname orb.yml)
        name: Ensure destination path
    - run:
        command: |
          circleci orb pack --skip-update-check src > orb.yml
        name: Pack src to orb.yml
    - run:
        command: circleci orb --skip-update-check validate orb.yml
        name: Validate whether this is a well-formed orb.
    - persist_to_workspace:
        paths:
        - orb.yml
        root: .
    - store_artifacts:
        path: orb.yml
  shellcheck/check:
    docker:
    - image: koalaman/shellcheck-alpine:v0.7.1
    steps:
    - checkout
    - run:
        command: |2

          Set_SHELLCHECK_EXCLUDE_PARAM() {
              if [ -n "$SC_PARAM_EXCLUDE" ]; then
                  SHELLCHECK_EXCLUDE_PARAM="--exclude=$SC_PARAM_EXCLUDE "
              else
                  SHELLCHECK_EXCLUDE_PARAM=""
              fi
          }

          Check_for_shellcheck() {
              if ! command -v shellcheck &> /dev/null
              then
                  echo "Shellcheck not installed"
                  exit
              fi
          }

          Run_ShellCheck() {
              SC_PARAM_PATTERN="${SC_PARAM_PATTERN:-"*.sh"}"
              find "$SC_PARAM_DIR" ! -name "$(printf "*\n*")" -name "$SC_PARAM_PATTERN" > tmp
              set +e
              while IFS= read -r script
              do
                  # shellcheck disable=SC2086
                  shellcheck $SHELLCHECK_EXCLUDE_PARAM --shell=$SC_PARAM_SHELL --severity=$SC_PARAM_SEVERITY "$script" >> $SC_PARAM_OUTPUT
              done < tmp
              set -eo pipefail
          }

          Catch_SC_Errors() {
              if [ -s "$SC_PARAM_OUTPUT" ]; then
                  printf '\e[1;31mShellCheck Errors Found\e[0m\n'
                  cat "$SC_PARAM_OUTPUT"
                  exit 1
              else
                  printf '\e[1;32mNo ShellCheck Errors Found\e[0m\n'
              fi
          }

          SC_Main() {
              Check_for_shellcheck
              Set_SHELLCHECK_EXCLUDE_PARAM
              Run_ShellCheck
              Catch_SC_Errors
              rm tmp
          }


          # Will not run if sourced for bats.
          # View src/tests for more information.
          TEST_ENV="bats-core"
          if [ "${0#*$TEST_ENV}" == "$0" ]; then
              SC_Main
          fi
        environment:
          SC_PARAM_DIR: ./src/scripts
          SC_PARAM_EXCLUDE: SC2148
          SC_PARAM_OUTPUT: shellcheck.log
          SC_PARAM_PATTERN: ''
          SC_PARAM_SEVERITY: style
          SC_PARAM_SHELL: bash
        name: Run Shellcheck
    - store_artifacts:
        destination: shellcheck
        path: shellcheck.log
  bats/run:
    docker:
    - image: cimg/base:stable
    steps:
    - checkout
    - run:
        command: "#!/bin/bash\n\ncheckRequirements() {\n    if ! command -v git &> /dev/null\n    then\n        echo \"git is required to install BATS\"\n        exit 1\n    fi\n    # TODO: revisit if SUDO is needed. Keeping for patch compatability\n    if [[ $EUID == 0 ]]; then export SUDO=\"\"; else export SUDO=\"sudo\"; fi\n}\n\ninstallBats() {\n    checkRequirements\n    cd /tmp || exit 1\n    git clone https://github.com/bats-core/bats-core.git\n    cd /tmp/bats-core || exit 1\n    $SUDO ./install.sh /usr/local\n    if ! command -v bats &> /dev/null\n    then\n        echo \"BATS failed to install\"\n        echo \"Please open an issue at: https://github.com/CircleCI-Public/BATS-orb/issues\"\n        exit 1\n    else\n        echo \"BATS installed successfully\"\n    fi\n}\n\nsetupBats() {\n    if ! command -v bats &> /dev/null \n    then\n    # BATS is not installed\n        installBats\n    else\n    # BATS is installed\n        echo \"BATS is already available\"\n    fi\n}\n\nsetupBats\n"
        name: Install BATS-Core
    - run:
        command: "#!/bin/bash\n# This script is ran within the 'run' job, which will check \n#   for the existence of BATS prior to running this script.\nbats \"$ORB_VAL_PATH\"\n"
        environment:
          ORB_VAL_PATH: ./src/tests
        name: Execute BATS tests
  orb-tools/publish-dev:
    docker:
    - image: circleci/circleci-cli:latest
    steps:
    - attach_workspace:
        at: workspace
    - run:
        command: "circleci orb publish --skip-update-check workspace/orb.yml helix/cdk@dev:alpha --token $CIRCLE_TOKEN \n"
        name: |
          Publish orb at workspace/orb.yml to helix/cdk@dev:alpha
    - run:
        command: "circleci orb publish --skip-update-check workspace/orb.yml helix/cdk@dev:${CIRCLE_SHA1:0:7} --token $CIRCLE_TOKEN \n"
        name: |
          Publish orb at workspace/orb.yml to helix/cdk@dev:${CIRCLE_SHA1:0:7}
    - store_artifacts:
        path: workspace/orb.yml
  trigger-integration-dev:
    docker:
    - image: cimg/base:edge
    steps:
    - checkout
    - run:
        command: |
          # Quietly try to make the install directory.
          mkdir -p ~/bin | true

          # Selectively export the SUDO command, depending if we have permission
          # for a directory and whether we're running alpine.
          if [[ $EUID == 0 ]]; then export SUDO=""; else # Check if we're root
            if cat /etc/issue | grep Alpine > /dev/null 2>&1 || ! [[ -w "~/bin" ]]; then
              export SUDO="sudo";
            fi
          fi

          # If our first mkdir didn't succeed, we needed to run as sudo.
          if [ ! -w ~/bin ]; then
            $SUDO mkdir -p ~/bin
          fi

          echo 'export PATH=$PATH:~/bin' >> $BASH_ENV
          source $BASH_ENV

          # check if jq needs to be installed
          if command -v jq >> /dev/null 2>&1; then

              echo "jq is already installed..."

            if [[ false == true ]]; then
              echo "removing it."
              $SUDO rm -f $(command -v jq)
            else
              echo "ignoring install request."
              exit 0
            fi
          fi

          # Set jq version
          if [[ latest == "latest" ]]; then
            JQ_VERSION=$(curl -Ls -o /dev/null -w %{url_effective} "https://github.com/stedolan/jq/releases/latest" | sed 's:.*/::')
            echo "Latest version of jq is $JQ_VERSION"
          else
            JQ_VERSION=latest
          fi

          # extract version number
          JQ_VERSION_NUMBER_STRING=$(echo $JQ_VERSION | sed -E 's/-/ /')
          arrJQ_VERSION_NUMBER=($JQ_VERSION_NUMBER_STRING)
          JQ_VERSION_NUMBER="${arrJQ_VERSION_NUMBER[1]}"

          # Set binary download URL for specified version
          # handle mac version
          if uname -a | grep Darwin > /dev/null 2>&1; then
            JQ_BINARY_URL="https://github.com/stedolan/jq/releases/download/${JQ_VERSION}/jq-osx-amd64"
          else
            # linux version
            JQ_BINARY_URL="https://github.com/stedolan/jq/releases/download/${JQ_VERSION}/jq-linux64"
          fi

          jqBinary="jq-$PLATFORM"

          if [ -d "$JQ_VERSION/sig" ]; then
            # import jq sigs

            if uname -a | grep Darwin > /dev/null 2>&1; then
              HOMEBREW_NO_AUTO_UPDATE=1 brew install gnupg coreutils

              PLATFORM=osx-amd64
            else
              if cat /etc/issue | grep Alpine > /dev/null 2>&1; then
                $SUDO apk add gnupg > /dev/null 2>&1
              fi
              PLATFORM=linux64
            fi

            gpg --import "$JQ_VERSION/sig/jq-release.key" > /dev/null

            curl --output "$JQ_VERSION/sig/v$JQ_VERSION_NUMBER/jq-$PLATFORM" \
                --silent --show-error --location --fail --retry 3 \
                "$JQ_BINARY_URL"

            # verify sha256sum, sig, install

            gpg --verify "$JQ_VERSION/sig/v$JQ_VERSION_NUMBER/jq-$PLATFORM.asc"

            pushd "$JQ_VERSION/sig/v$JQ_VERSION_NUMBER" && grep "jq-$PLATFORM" "sha256sum.txt" | \
            sha256sum -c -
            popd
            jqBinary="$JQ_VERSION/sig/v$JQ_VERSION_NUMBER/jq-$PLATFORM"

          else
            curl --output "$jqBinary" \
              --silent --show-error --location --fail --retry 3 \
              "$JQ_BINARY_URL"
          fi

          $SUDO mv "$jqBinary" ~/bin/jq
          $SUDO chmod +x ~/bin/jq

          # cleanup
          [[ -d "./$JQ_VERSION" ]] && rm -rf "./$JQ_VERSION"

          # verify version
          echo "jq has been installed to $(which jq)"
          echo "jq version:"
          echo "$(jq --version)"
        name: Install jq
        when: always
    - run:
        command: |-
          Setup() {
              VCS_TYPE=$(echo "${CIRCLE_BUILD_URL}" | cut -d '/' -f 4)
              T=$(eval echo "$TOKEN")
          }

          BuildParams() {
              PARAM_MAP=$(eval echo $PARAM_MAP)
              REQUEST_PARAMS='{\"branch\": \"$CIRCLE_BRANCH\", \"parameters\": $PARAM_MAP}'
              eval echo $REQUEST_PARAMS > pipelineparams.json
          }

          DoCurl() {
              curl -u "${T}": -X POST --header "Content-Type: application/json" -d @pipelineparams.json \
                "https://circleci.com/api/v2/project/${VCS_TYPE}/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/pipeline" -o /tmp/curl-result.txt
          }

          Result() {
              CURL_RESULT=$(cat /tmp/curl-result.txt)
              if [[ $(echo "$CURL_RESULT" | jq -r .message) == "Not Found" || $(echo "$CURL_RESULT" | jq -r .message) == "Permission denied" || $(echo "$CURL_RESULT" | jq -r .message) == "Project not found" ]]; then
                  echo "Was unable to trigger integration test workflow. API response: $(cat /tmp/curl-result.txt | jq -r .message)"
                  exit 1
              else
                  echo "Pipeline triggered!"
                  echo "https://app.circleci.com/jobs/${VCS_TYPE}/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/$(cat /tmp/curl-result.txt | jq -r .number)"
              fi
          }

          Main() {
              Setup
              BuildParams
              DoCurl
              Result
          }

          # Will not run if sourced for bats.
          # View src/tests for more information.
          TEST_ENV="bats-core"
          if [ "${0#*$TEST_ENV}" == "$0" ]; then
              Main
          fi
        environment:
          PARAM_MAP: '{\"run-integration-tests\": true, \"dev-orb-version\": \"dev:${CIRCLE_SHA1:0:7}\"}'
          TOKEN: $CIRCLE_TOKEN
        name: Trigger integration test workflow
workflows:
  test-pack:
    jobs:
    - orb-tools/lint
    - orb-tools/pack
    - shellcheck/check
    - bats/run
    - orb-tools/publish-dev:
        requires:
        - orb-tools/lint
        - orb-tools/pack
        - bats/run
        - shellcheck/check
        context: orb-publishing
    - trigger-integration-dev:
        requires:
        - orb-tools/publish-dev
        context: orb-publishing
  version: 2
